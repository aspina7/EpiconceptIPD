---
title: "EpiconceptIPD"
author: "Investigation team"
date: "04 Oktober 2018"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  oncordance = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 9,
  fig.height = 6
  )
```

```{r packages4knit, echo = FALSE}
#load packages
  #Those required for creating this markdown: 
    #"Worded": for styling and pagebreaks (devtools::install_github("davidgohel/worded"))
    #"knitr": for styling tables
required_packages <- c("worded", "knitr") 

for (i in seq(along = required_packages)) {
  library(required_packages[i], character.only = TRUE)
}

# The dataset for time series will probably come mid-next week. It will be Scottish data with several years of pre-vaccination data (2000-2006), 3 years of PCV7 years (2007-2009) and 8 years of PCV13 years (2010-2017). 
```

## Working directory

You can check the path for your current working directory using the `getwd` function.

```{r, eval = FALSE}
# Check your current working directory
getwd()
```

To set your working directory you can use the `setwd` function. 

```{r, eval = FALSE}
setwd("C:/Users/Username/Desktop/EpiconceptIPD")
```

## Reading in data

Import the dataset from a comma seperated file (.csv) using the `read.csv` function, storing it as a dataframe within *R* called *ipd_cases*. Further, import population data using the same approach (*population*). For a CSV file the separator is normally a comma (","), however depending on the language of your operating system this can also be other values, for example some non-english speaking European countries use a semi-colon (";") as standard. Here we also specify that we do not want to format strings as factors. When reading population data we additionally define the option `check.names = FALSE` which makes sure that variable names are kept as defined in the CSV. By default (`check.names = TRUE`) *R* would automatically change column names to follow certain rules (e.g. no numeric as first character).

```{r read_data}
ipd_cases <- read.csv("data/ipd_cases.csv", sep = ",", stringsAsFactors = FALSE)
population <- read.csv("data/ipd_population.csv", sep = ",", stringsAsFactors = FALSE, check.names = FALSE)
```

### Define more variables that will be needed

The PCV7 covers IPD serotypes 4, 6B, 9V, 14, 18C, 19F and 23F, and PCV13 covers 4, 6B, 9V, 14, 18C, 19F, 23F, 1, 5, 7F, 3, 6A and 19A. Let us now define two variables which represent the serotypes covered by the two vaccines. We will use those variables later to identify cases with either PCV7 or PCV13 serotypes respectively. We will e.g. call a case a "PCV7 case" if the identified serotype is one of the PCV7 serotypes.
```{r vaccine_definition}
pcv7  <- c("4", "6B", "9V", "14", "18C", "19F", "23F")
pcv13 <- c("4", "6B", "9V", "14", "18C", "19F", "23F", "1", "5", "7F", "3", "6A", "19A")
```

## Observe the data

Take a look at the first 10 rows of the data or browse the dataframe in the RStudio preview.

```{r, eval = FALSE}
head(ipd_cases, n = 10)
# or
View(ipd_cases)
```
Remember that `View` needs to be written with a capital *V*.

```{r, echo = FALSE}
kable(head(ipd_cases, n = 10))
```

Another option is to use *R*'s `str` function to display the structure of an *R* object compactly.

```{r}
str(ipd_cases)
```
You get a short overview of the dimensions of the dataset (number of observations, number of variables) and additionally the class of each variable including the first couple of observations.

It is often useful to inspect character and factor variables separately to get to know the used values and labels and find out about potential spelling mistakes and different styles. Use the `unique` function on each of the character variables to get a list of all unique values in each variable.

```{r, eval = FALSE}
unique(ipd_cases$Month)
unique(ipd_cases$AgeGroup)
unique(ipd_cases$Serotype)
```

## Data cleaning, recoding and fixing data

Clean and change the dataset as needed for further analyses.

Necessary changes:

- Make sure that the `ipd_cases$Month` only contains the values 1-12 (Jan-Dec).
- Unify the spelling/style of `ipd_cases$Serotype`.
- Define two columns in our data to indicate if the case corresponds to PCV7 and/or PCV13 serotypes, respectively.

```{r}
# decide if this should be taken out and a "clean" dataset should be available
ipd_cases$Month[!ipd_cases$Month %in% 1:12] <- NA

ipd_cases$Serotype <- gsub(pattern = "serotype ", replacement = "", x = ipd_cases$Serotype, fixed = TRUE)

```

Define two columns in our data to indicate if the case corresponds to PCV7 and/or PCV13 serotypes, respectively. Values in these columns are either `TRUE` or `FALSE`.
```{r}
ipd_cases$PCV7 <- ipd_cases$Serotype %in% pcv7
ipd_cases$PCV13 <- ipd_cases$Serotype %in% pcv13
```

## Basic statistics/analyses

Tabulate cases by year and age-group.
```{r}
annual_cases <- addmargins(table(ipd_cases$Year, ipd_cases$AgeGroup), 2, FUN = list(Total = sum))
```

```{r, eval = FALSE}
View(annual_cases)
```

```{r, echo = FALSE}
kable(annual_cases)
```

Create tables of PCV7 (*annual_pcv7*) and PCV13 (*annual_pcv13*) cases by year and age-group. Remember, PCV7 was introduced in 2007, and PCV13 in 2010.
```{r}
annual_pcv7 <- addmargins(table(ipd_cases$Year[ipd_cases$PCV7], 
                              ipd_cases$AgeGroup[ipd_cases$PCV7]), 
                        margin = 2, FUN = list(Total = sum))
annual_pcv13 <- addmargins(table(ipd_cases$Year[ipd_cases$PCV13], 
                               ipd_cases$AgeGroup[ipd_cases$PCV13]), 
                         margin = 2, FUN = list(Total = sum))
```


Plot annual cases and highlight years with PCV7/13 introduction (red dashed vertical lines).

**PCV7:**
```{r}
plot(rownames(annual_pcv7), annual_pcv7[, "Total"], type = "l",
     xlab = "Year", ylab = "Number of cases",
     main = "IPD cases of PCV7 serotypes, total population",
     sub = "red dashed: PCV7 and PCV13 introduction, respectively",
     ylim = c(0, 450))
points(rownames(annual_pcv7), annual_pcv7[, "Total"])
abline(v = c(2007, 2010), col = "red", lty = "dashed")
```

**PCV13:**
```{r}
plot(rownames(annual_pcv13), annual_pcv13[, "Total"], type = "l",
     xlab = "Year", ylab = "Number of cases",
     main = "IPD cases of PCV13 serotypes, total population",
     sub = "red dashed: PCV7 and PCV13 introduction, respectively",
     ylim = c(0, 700))
points(rownames(annual_pcv13), annual_pcv13[, "Total"])
abline(v = c(2007, 2010), col = "red", lty = "dashed")
```

## Segmented regression

We can use segmented regression to assess the impact of a certain intervention, such es the introduction of a vaccine programme. You can think of that the data is devided into two segments (or periods), before and after the intervention, and regression models are estimated for both time periods. To do so, you could of course also split the time series in those two segments and run regression models for each. However, the advantage of segmented regression is that estimates for both segments come from the same model and therefore it is easy to calculate the effect of the intervention (which can sloppy be defined as the difference of the two segments) and confidence intervals directly from the model.

We will need the `glm.nb` function from the *MASS* package to perform negative binomial regression. Additionally we will use the `tidy` function from the *broom* package to create nice model outputs. If you did not yet install these packages, do so using the `install.packages` function.
```{r, eval = FALSE}
install.packages("MASS")
install.packages("broom")
```

Now load the required packages.
```{r}
library(MASS)
library(broom)
```

In gerneral, the negative binomial regression model can be written as

$log(Y_t) = \beta_0 + \beta_1 * t + \beta_2 * \delta(t-t_0) + \beta_3 * (t - t_0)^+ + log(pop_t) + e_t$

Here, $Y_t$ is the number of IPD cases observed in year $t$; $pop_t$ is the population size in 100,000 in year $t$, $t_0$ is the last year (year 7) of the pre-period (including the transition time if there is any), $\delta(x)$ is the indicator function (it is 0 if $x\le 0$ and 1 if $x > 0$), $(x)^+$ is the cut off operator (it is $x$ if $x>0$ and 0 otherwise), and $e_t$ denotes the residual. This means, that $\beta_2 * \delta(t-t_0) + \beta_3 * (t - t_0)^+$ is the additional generalised linear part of the post-period, which is zero in the pre-period. The estimates of $\beta_2$ and $\beta_3$ will denote the effects of the intervention. Of course more periods and terms to control for seasonality can be added if needed.

In the following we will analyse annual incidence of PCV13 serotypes among the whole population (*total*). As PCV7 serotypes are also covered by PCV13 and we already see an impact on PCV13 serotypes we consider 2007 as time of intervention. Analoguously sub-populations and other intervention definitions can be analysed. To get (to some extent) robust results a certain amount of time points per period and a certain amount of observations per time point should be available. It is desirable to have 12 time points per period (not fulfilled in our example) and  100 observations (cases) per each time point. However, those numbers are rough suggestions and do not rely on power estimates.

First, transform the table (*annual_pcv13*) into a data.frame. Use the *R* function `as.data.frame.matrix` to do so.
Check the class of *annual_pcv13*:
```{r}
class(annual_pcv13)
```

In our case, the year is stored as row name and not as a column itself. Therefore transform the data into a data.frame as explained above and add the year as seperate column. Make sure that the year column is of class numeric.
```{r}
pcv13_aggr <- as.data.frame.matrix(annual_pcv13)
pcv13_aggr$year <- as.numeric(rownames(pcv13_aggr))
```

Merge population and keep necessary columns only.
```{r}
pcv13_df <- merge(pcv13_aggr, population, by = "year", all.x = TRUE, suffixes = c("", "_pop"))
pcv13_df <- pcv13_df[, c("year", "Total", "Total_pop")]
```

Define parameters and columns needed for segmented regression.
```{r}
intervention_year <- 2007

pcv13_df$linear <- 1:nrow(pcv13_df) # corresponds to t in the formula
pcv13_df$const_vacc <- as.numeric(pcv13_df$year >= intervention_year) # corresponds to delta(t-t0) in the formula
pcv13_df$lin_vacc <- pmax(0, pcv13_df$year - intervention_year + 1) # corresponds to (t-t0)+ in the formula

pcv13_df$pop100 <- pcv13_df$Total_pop / 100000
```

Segmented negative binomial regression with population per 100.000 as offset:
```{r}
# negative binomial segmented regression
nb <- glm.nb(Total ~ linear + const_vacc + lin_vacc + offset(log(pop100)), data = pcv13_df)
```

### Interpretation of intervention effects
Create table with results. Use the `tidy` function from *broom* package to simplify the regression output.
```{r}
nb_tidy <- tidy(nb, exponentiate = FALSE, conf.int = TRUE)
```

Take a look using
```{r, eval = FALSE}
View(nb_tidy)
```

```{r, echo = FALSE}
kable(nb_tidy)
```

Exponentiate the estimates to make them interpretable as Incidence Rate Ratios. The Intercept is then just the estimate of baseline incidence per 100.000.

```{r}
nb_tidy_exp <- tidy(nb, exponentiate = TRUE, conf.int = TRUE)
```

```{r, eval = FALSE}
View(nb_tidy_exp)
```

```{r, echo = FALSE}
kable(nb_tidy_exp)
```

The percentage change of the anual incidence by year can be computed using the formula
$IC\% = 100 * (\exp(\hat{\beta}) - 1)$.

Therefore, after the intervention, the anual incidence changed by `r paste0("$100 * (\\exp(", round(nb_tidy$estimate[4],3) , ") - 1) = ", round(100*(exp(nb_tidy$estimate[4])-1), 1), "\\%$")` controlled for the baseline trend.

### Plot the result

Prepare the data.frame for plotting. Calculate model predictions of incidence and confidence intervals.
```{r}
nb_predict <- pcv13_df
nb_predict$pop100 <- 1
pred.ci <- predict(nb, nb_predict, type = "link", se.fit = TRUE)
pred.ci <- within(pred.ci, {
  inci <- exp(fit)
  LL <- exp(fit - 1.96 * se.fit)
  UL <- exp(fit + 1.96 * se.fit)
})

nb_predict$inci_observed <- nb_predict$Total / nb_predict$Total_pop * 100000
nb_predict$inci_modelled <- pred.ci$inci
nb_predict$lowerCI <- pred.ci$LL
nb_predict$upperCI <- pred.ci$UL

# split into 2 data.frames for plotting. One for the pre- and the other for the post-period
pre <- nb_predict[nb_predict$year < intervention_year, ]
post <- nb_predict[nb_predict$year >= intervention_year, ]

```

```{r}
plot(nb_predict$year, nb_predict$inci_observed, type = "p",
     xlab = "Year", ylab = "Number of cases per 100.000 pop",
     main = "IPD incidence of PCV13 serotypes, total population",
     sub = "red dashed: PCV7 introduction",
     xlim = range(nb_predict$year),
     ylim = c(0, 15))

lines(pre$year, pre$inci_modelled, type = "l")
lines(pre$year, pre$lowerCI, type = "l", lty = "dashed")
lines(pre$year, pre$upperCI, type = "l", lty = "dashed")

lines(post$year, post$inci_modelled, type = "l")
lines(post$year, post$lowerCI, type = "l", lty = "dashed")
lines(post$year, post$upperCI, type = "l", lty = "dashed")

abline(v = c(2007), col = "red", lty = "dashed")
```















