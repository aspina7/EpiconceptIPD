---
title: "EpiconceptIPD"
author: "Investigation team"
date: "04 Oktober 2018"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  oncordance = TRUE,
  message = FALSE,
  warning = FALSE
  )
```

```{r packages4knit, echo = FALSE}
#load packages
  #Those required for creating this markdown: 
    #"Worded": for styling and pagebreaks (devtools::install_github("davidgohel/worded"))
    #"knitr": for styling tables
required_packages <- c("worded", "knitr") 

for (i in seq(along = required_packages)) {
  library(required_packages[i], character.only = TRUE)
}

# The dataset for time series will probably come mid-next week. It will be Scottish data with several years of pre-vaccination data (2000-2006), 3 years of PCV7 years (2007-2009) and 8 years of PCV13 years (2010-2017). 
```

## Working directory

You can check the path for your current working directory using the `getwd` function.

```{r, eval = FALSE}
# Check your current working directory
getwd()
```

To set your working directory you can use the `setwd` function. 

```{r, eval = FALSE}
setwd("C:/Users/Username/Desktop/EpiconceptIPD")
```

## Reading in data

Import the dataset from a comma seperated file (.csv) using the `read.csv` function, storing it as a dataframe within *R* called *ipd_cases*. Further, import population data using the same approach (*population*). For a CSV file the separator is normally a comma (","), however depending on the language of your operating system this can also be other values, for example some non-english speaking European countries use a semi-colon (";") as standard. Here we also specify that we do not want to format strings as factors. When reading population data we additionally define the option `check.names = FALSE` which makes sure that variable names are kept as defined in the CSV. By default (`check.names = TRUE`) *R* would automatically change column names to follow certain rules (e.g. no numeric as first character).

```{r read_data}
ipd_cases <- read.csv("data/ipd_cases.csv", sep = ",", stringsAsFactors = FALSE)
population <- read.csv("data/ipd_population.csv", sep = ",", stringsAsFactors = FALSE, check.names = FALSE)
```

### Define more variables that will be needed

Let us now define two variables which represent the serotypes covered by PCV7 and PCV13. We will use those variables later to identify cases with either so-called PCV7 or PCV13 serotypes respectively. We will e.g. call a case a "PCV7 case" if the identified serotype is one of the PCV7 serotypes.
```{r vaccine_definition}
pcv7  <- c("4", "6B", "9V", "14", "18C", "19F", "23F")
pcv13 <- c("4", "6B", "9V", "14", "18C", "19F", "23F", "1", "5", "7F", "3", "6A", "19A")
```

## Observe the data

Take a look at the first 10 rows of the data or browse the dataframe in the RStudio preview.

```{r, eval = FALSE}
head(ipd_cases, n = 10)
# or
View(ipd_cases)
```
Remember that `View` needs to be written with a capital *V*.

```{r, echo = FALSE}
kable(head(ipd_cases, n = 10))
```

Another option is to use *R*'s `str` function to display the structure of an *R* object compactly.

```{r}
str(ipd_cases)
```
You get a short overview of the dimensions of the dataset (number of observations, number of variables) and additionally the class of each variable including the first couple of observations.

It is often useful to inspect character and factor variables separately to get to know the used values and labels and find out about spelling mistakes and different styles. Use the `unique` function on each of the character variables to get a list of all unique values in each variable.

```{r, eval = FALSE}
unique(ipd_cases$Month)
unique(ipd_cases$AgeGroup)
unique(ipd_cases$Serotype)
```

## Data cleaning, recoding and fixing data

Clean and change the dataset as needed for further analyses.

Necessary changes:

- Make sure that the `ipd_cases$Month` only contains the values 1-12 (Jan-Dec).
- Unify the spelling/style of `ipd_cases$Serotype`.
- Define two columns in our data to indicate if the case corresponds to PCV7 and/or PCV13 serotypes, respectively.

```{r}
# decide if this should be taken out and a "clean" dataset should be available
ipd_cases$Month[!ipd_cases$Month %in% 1:12] <- NA

ipd_cases$Serotype <- gsub(pattern = "serotype ", replacement = "", x = ipd_cases$Serotype, fixed = TRUE)

```

Define two columns in our data to indicate if the case corresponds to PCV7 and/or PCV13 serotypes, respectively. Values in these columns are either `TRUE` or `FALSE`.
```{r}
ipd_cases$PCV7 <- ipd_cases$Serotype %in% pcv7
ipd_cases$PCV13 <- ipd_cases$Serotype %in% pcv13
```

## Basic statistics/analyses

Tabulate cases by year and age-group.
```{r}
all_year <- addmargins(table(ipd_cases$Year, ipd_cases$AgeGroup), 2, FUN = list(Total = sum)) # find better name for df
```

```{r, eval = FALSE}
View(all_year)
```

```{r, echo = FALSE}
kable(all_year)
```

Create tables of PCV7 (*pcv7_year*) and PCV13 (*pcv13_year*) cases by year and age-group. Remember, PCV7 was introduced in 2007, and PCV13 in 2010.
```{r}
pcv7_year <- addmargins(table(ipd_cases$Year[ipd_cases$PCV7], 
                              ipd_cases$AgeGroup[ipd_cases$PCV7]), 
                        margin = 2, FUN = list(Total = sum))
pcv13_year <- addmargins(table(ipd_cases$Year[ipd_cases$PCV13], 
                               ipd_cases$AgeGroup[ipd_cases$PCV13]), 
                         margin = 2, FUN = list(Total = sum))
```


Plot annual cases and highlight years with PCV7/13 introduction (red dashed vertical lines).

**PCV7:**
```{r}
plot(rownames(pcv7_year), pcv7_year[, "Total"], type = "l",
     xlab = "Year", ylab = "Number of cases",
     main = "IPD cases of PCV7 serotypes, total population",
     sub = "red dashed: PCV7 and PCV13 introduction, respectively",
     ylim = c(0, 450))
points(rownames(pcv7_year), pcv7_year[, "Total"])
abline(v = c(2007, 2010), col = "red", lty = "dashed")
```

**PCV13:**
```{r}
plot(rownames(pcv13_year), pcv13_year[, "Total"], type = "l",
     xlab = "Year", ylab = "Number of cases",
     main = "IPD cases of PCV13 serotypes, total population",
     sub = "red dashed: PCV7 and PCV13 introduction, respectively",
     ylim = c(0, 700))
points(rownames(pcv13_year), pcv13_year[, "Total"])
abline(v = c(2007, 2010), col = "red", lty = "dashed")
```

## Segmented regression
We will need the `glm.nb` function from the *MASS* package to perform negative binomial regression. Additionally we will use the `tidy` function from the *broom* package to create nice model outputs. If you did not yet install these packages, do so using the `install.packages` function.
```{r, eval = FALSE}
install.packages("MASS")
install.packages("broom")
```

Now load the required packages.
```{r}
library(MASS)
library(broom)
```

Negative binomial regression model:

$log(Y_t) = \beta_0 + \beta_1 * t + \beta_2 * \delta(t-t_0) + \beta_3 * (t - t_0)^+ + log(pop_t) + e_t$

Here, $Y_t$ is the number of IPD cases observed in year $t$; $pop_t$ is the population size in 100,000 in year $t$, $t_0$ is the last year (year 7) of the pre-period (including the transition time if there is any), $\delta(x)$ is the indicator function (it is 0 if $x \leï‚£0$ and 1 if $x > 0$), $(x)^+$ is the cut off operator (it is $x$ if $x>0$ and 0 otherwise), and $e_t$ denotes the residual. This means, that $\beta_2 * \delta(t-t_0) + \beta_3 * (t - t_0)^+$ is the additional generalised linear part of the post-period, which is zero in the pre-period. The estimates of $\beta_2$ and $\beta_3$ will denote the effects of the intervention.

*TODO: Explain why we look at PCV13 IPD only and use PCV7 introduction as intervention (good to practice, easy enough, still big samplesize, 6 additional STs seem to not have that big of an impact, ...).*

We will analyse annual incidence of PCV13 serotypes among the whole population (*total*).

First, transform the table (*pcv13_year*) into a data.frame. Use the *R* function `as.data.frame.matrix` to do so.
Check the class of *pcv13_year*:
```{r}
class(pcv13_year)
```

In our case, the year is stored as row name and not as a column itself. Therefore transform the data into a data.frame as explained above and add the year as seperate column. Make sure that the year column is of class numeric.
```{r}
pcv13_aggr <- as.data.frame.matrix(pcv13_year)
pcv13_aggr$year <- as.numeric(rownames(pcv13_aggr))
```

Merge population and keep necessary columns only.
```{r}
pcv13_df <- merge(pcv13_aggr, population, by = "year", all.x = TRUE, suffixes = c("", "_pop"))
pcv13_df <- pcv13_df[, c("year", "Total", "Total_pop")]
```

Define parameters and columns needed for segmented regression (TODO: to be explained explicitely)

```{r}
intervention_year <- 2007

pcv13_df$linear <- 1:nrow(pcv13_df)
pcv13_df$const_vacc <- as.numeric(pcv13_df$year >= intervention_year)
pcv13_df$lin_vacc <- pmax(0, pcv13_df$year - intervention_year + 1)

pcv13_df$pop100 <- pcv13_df$Total_pop / 100000
```

Segmented negative binomial regression
```{r}
# negative binomial segmented regression
nb <- glm.nb(Total ~ linear + const_vacc + lin_vacc + offset(log(pop100)), data = pcv13_df)
```

### Interpretation of intervention effects
Create table with results. Use the `tidy` function from *broom* package to simplify the regression output.
```{r}
nb_tidy <- tidy(nb, exponentiate = FALSE, conf.int = TRUE)
```

Take a look using
```{r, eval = FALSE}
View(nb_tidy)
```

```{r, echo = FALSE}
kable(nb_tidy)
```

Exponentiate the estimates to make them interpretable as Incidence Rate Ratios. The Intercept is then just the estimate of baseline incidence per 100.000.

```{r}
nb_tidy_exp <- tidy(nb, exponentiate = TRUE, conf.int = TRUE)
```

```{r, eval = FALSE}
View(nb_tidy_exp)
```

```{r, echo = FALSE}
kable(nb_tidy_exp)
```

The percentage change of the anual incidence can be computed using the formula
$IC\% = 100 * (\exp(\hat{\beta}) - 1)$.

Therefore, after the intervention, the anual incidence changed by `r paste0("$100 * (\\exp(", round(nb_tidy$estimate[4],3) , ") - 1) = ", round(100*(exp(nb_tidy$estimate[4])-1), 1), "\\%$")` controlled for the baseline trend.

### Plot the result

Prepare the data.frame for plotting. Calculate model predictions of incidence and confidence intervals.
```{r}
nb_predict <- pcv13_df
nb_predict$pop100 <- 1
pred.ci <- predict(nb, nb_predict, type = "link", se.fit = TRUE)
pred.ci <- within(pred.ci, {
  inci <- exp(fit)
  LL <- exp(fit - 1.96 * se.fit)
  UL <- exp(fit + 1.96 * se.fit)
})

nb_predict$inci_observed <- nb_predict$Total / nb_predict$Total_pop * 100000
nb_predict$inci_modelled <- pred.ci$inci
nb_predict$lowerCI <- pred.ci$LL
nb_predict$upperCI <- pred.ci$UL

# split into 2 data.frames for plotting. One for the pre- and the other for the post-period
pre <- nb_predict[nb_predict$year < intervention_year, ]
post <- nb_predict[nb_predict$year >= intervention_year, ]

```

```{r}
plot(nb_predict$year, nb_predict$inci_observed, type = "p",
     xlab = "Year", ylab = "Number of cases per 100.000 pop",
     main = "IPD incidence of PCV13 serotypes, total population",
     sub = "red dashed: PCV7 introduction",
     xlim = range(nb_predict$year),
     ylim = c(0, 15))

lines(pre$year, pre$inci_modelled, type = "l")
lines(pre$year, pre$lowerCI, type = "l", lty = "dashed")
lines(pre$year, pre$upperCI, type = "l", lty = "dashed")

lines(post$year, post$inci_modelled, type = "l")
lines(post$year, post$lowerCI, type = "l", lty = "dashed")
lines(post$year, post$upperCI, type = "l", lty = "dashed")

abline(v = c(2007), col = "red", lty = "dashed")
```

*Explain how to calculate effects (see Wagner et al. 2002)*













